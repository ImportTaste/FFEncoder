<#
    .SYNOPSIS
        Script for encoding 4K HDR and 1080p content using ffmpeg
    
    .DESCRIPTION
        This script is meant to make video encoding easier with ffmpeg. Instead of manually changing
        the script parameters each time it is run, you can pass parameters to this script and it will 
        use the arguments as needed. Supports 2160p HDR and 1080p resolutions. 

    .EXAMPLE 
        .\FFEncoder.ps1 -InputPath "Path\To\file" -CRF 16.5 -Deblock -2,-2 -MaxLuminance 1000 -MinLuminance .0050 -MaxCLL 1347 -MinCLL 129 -OutputPath "Path\To\New\File"

    .OUTPUTS
        crop.txt - This file is saved in the same directory as your video file, and is used for auto-cropping
        4K HDR encoded video file
        1080p encoded video file

    .NOTES
        For this script to work, ffmpeg must be in your PATH (consult your OS documentation for info on how to do this)

        Be sure to include ".mkv" or ".mp4" at the end of your output file, or you will be left with a file that will not play. 
        These are the only containers supported.

        This script is designed to encode video ONLY. ffmpeg does not have great passthrough options for Atmos or DTS-X (yet), 
        so it is easier to mux the audio yourself using MKVToolNix. By default, ffmpeg will convert audio streams to Vorbis.
        When your video is done encoding, simply mux the Vorbis out and replace it with your audio stream of choice.

        I currently have this script working on Windows, and plan to add support for UNIX shortly.

#>

[CmdletBinding(DefaultParameterSetName = "2160p")]
param (
    #switch test run on. only encode the first 1500 frames
    [Parameter(Mandatory = $false, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $false, ParameterSetName = "1080p")]
    [Alias("T")]
    [switch]$Test,

    #switch flag to run a 1080p encode instead of 2160p
    [Parameter(Mandatory = $true, ParameterSetName = "1080p")]
    [switch]$1080p,

    #input path for file to be encoded
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $true, ParameterSetName = "1080p")]
    [ValidateNotNullOrEmpty()]
    [Alias("I")]
    [string]$InputPath,

    #preset used by the x265 encoder
    [Parameter(Mandatory = $false, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $false, ParameterSetName = "1080p")]
    [ValidateSet("placebo", "veryslow", "slower", "slow", "medium", "fast", "faster", "veryfast", "superfast", "ultrafast")]
    [Alias("P")]
    [string]$Preset = "slow",

    #constant rate factor setting
    [Parameter(Mandatory = $false, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $false, ParameterSetName = "1080p")]
    [ValidateRange(0.0, 51.0)]
    [double]$CRF = 16.0,

    #deblock filter setting
    [Parameter(Mandatory = $false, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $false, ParameterSetName = "1080p")]
    [ValidateRange(-6, 6)]
    [Alias("DBF")]
    [int[]]$Deblock = @(-1, -1),

    #master display luminance max for HDR
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [ValidateNotNullOrEmpty()]
    [Alias("MaxL")]
    [int]$MaxLuminance,

    #master display luminance min for HDR
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [ValidateNotNullOrEmpty()]
    [Alias("MinL")]
    [double]$MinLuminance,

    #max content light level for HDR
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [ValidateNotNullOrEmpty()]
    [int]$MaxCLL,

    #min content light level for HDR
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [ValidateNotNullOrEmpty()]
    [int]$MinCLL,

    #output path of encoded file
    [Parameter(Mandatory = $true, ParameterSetName = "2160p")]
    [Parameter(Mandatory = $true, ParameterSetName = "1080p")]
    [ValidateNotNullOrEmpty()]
    [Alias("O")]
    [string]$OutputPath

)

## Global Variables ##

#Change these to modify the default path for crop files when a regex match cannot be made
$macDefaultPath = '~/Movies'
$linuxDefaultPath = '~/Videos'
$windowsDefaultPath = "C:\Users\$env:USERNAME\Videos"

#converting the luminance values for ffmpeg
$MaxLuminance = $MaxLuminance * 10000
[int]$MinLuminance = $MinLuminance * 10000
#Global variable that holds the crop file generated by New-CropFile function
$cropFilePath = ""

## End Global Variables ##

## Functions ##

#Returns an object with OS related information
function Get-OperatingSystem {
    if ($isMacOs) {
        $osInfo = @{
            OperatingSystem = "MacOS"
            DefaultPath     = $macDefaultPath
        } 
    }
    elseif ($isLinux) {
        $osInfo = @{
            OperatingSystem = "Linux"
            DefaultPath     = $linuxDefaultPath
        }
    }
    elseif ($env:OS -match "Windows") {
        $osInfo = @{
            OperatingSystem = "Windows"
            DefaultPath     = $windowsDefaultPath
        }
    }
    else { throw "Fatal error...could not detect operating system." }

    return $osInfo
}


<#
    generates a crop file which is used to calculate autocropping values for the video source

    .PARAMETER osType
            The current operating system.
#>
function New-CropFile ($osType) {
    if ($InputPath -match "(?<root>.*(?:\\|\/)+).*\.m[a-z 4]+") {
        $cropFileRoot = $Matches.root
        $cropFilePath = Join-Path -Path $cropFileRoot -ChildPath "crop.txt"
        Write-Host "Crop file path is " $cropFilePath "`n"
    }
    else {
        Write-Host "Could not match root folder. Using OS default path instead..."
        $os = Get-OperatingSystem
        Write-Host $os.OperatingSystem " detected. Using path: $($os.DefaultPath)`n"
        $cropFileRoot = $os.DefaultPath
        $cropFilePath = Join-Path -Path $cropFileRoot -ChildPath "crop.txt"
        Write-Host "Crop file path is " $cropFilePath "`n"
    }
    #if the crop file already exists (from a test run for example) return the path. Else, use ffmpeg to create one
    if (Test-Path -Path $cropFilePath) { 
        Write-Host "Crop file already exists`n"
        return $cropFilePath 
    }
    else {
        switch ($osType) {
            "Windows" { 
                ffmpeg.exe -skip_frame nokey -y -hide_banner -loglevel 32 -stats -i $InputPath -vf cropdetect -an -f null - 2>$cropFilePath
            }
            Default { Write-Host "OS could not be detected while generating the crop file. Exiting script..."; exit }
        }
        return $cropFilePath
    }
}

<#
    Enumerates the crop file to find the max crop width and height. This simulates autocropping from programs like Handbrake

    .PARAMETER cropPath
        The path to the crop file
#>
function Measure-CropDimensions ($cropPath) {
    if (!$cropPath) { throw "There was an issue reading the crop file. Check that the file was properly created and try again." }
    $cropFile = Get-Content $cropPath
    $cropHeight = 0
    $cropWidth = 0
    foreach ($line in $cropFile) {
        if ($line -match "Parsed_cropdetect.*w:(?<width>\d+) h:(?<height>\d+).*") {
            [int]$height = $Matches.height
            [int]$width = $Matches.width
    
            if ($width -gt $cropWidth) { $cropWidth = $width }
            if ($height -gt $cropHeight) { $cropHeight = $height }
        }
    }
    Write-Host "Crop Dimensions: " $cropWidth "x" $cropHeight
    return @($cropWidth, $cropHeight)
}
<#
    Runs ffmpeg with operating system specific parameters 

    .PARAMETER osType
        The current operating system.
#>
function Invoke-FFMpeg ($osType) {
    switch ($osType) {
        { $_ -match "Windows" } { 
            if ($Test) {
                ffmpeg.exe -probesize 100MB -i $InputPath `
                    -frames:v 1000 -vf "crop=w=$($cropDim[0]):h=$($cropDim[1])" -color_range tv -color_primaries 9 -color_trc 16 -colorspace 9 -c:v libx265 -preset $Preset -crf $CRF -pix_fmt yuv420p10le `
                    -x265-params "level-idc=5.1:min-keyint=23:keyint=250:deblock=$($deblock[0]),$($deblock[1]):sao=0:rc-lookahead=48:subme=4:chromaloc=2:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L($MaxLuminance,$MinLuminance):max-cll=$MaxCLL,$MinCLL`:hdr-opt=1" `
                    $OutputPath 2>&1
            }
            else {
                ffmpeg.exe -probesize 100MB -i $InputPath `
                    -vf "crop=w=$($cropDim[0]):h=$($cropDim[1])" -color_range tv -color_primaries 9 -color_trc 16 -colorspace 9 -c:v libx265 -preset $Preset -crf $CRF -pix_fmt yuv420p10le `
                    -x265-params "level-idc=5.1:min-keyint=23:keyint=250:deblock=$($deblock[0]),$($deblock[1]):sao=0:rc-lookahead=48:subme=4:chromaloc=2:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L($MaxLuminance,$MinLuminance):max-cll=$MaxCLL,$MinCLL`:hdr-opt=1" `
                    $OutputPath 2>&1
            }
        }
        Default { Write-Host "`nAn OS could not be matched while invoking ffmpeg. Exiting script..."; exit }
    }
}

## End Functions ##

######################################## Main Script Logic ########################################

Write-Host "`nStarting Script...`n`n"
$startTime = (Get-Date).ToLocalTime()

if (Test-Path -Path $OutputPath) {
    do {
        $response = Read-Host "The output path already exists. Would you like to delete it? (y/n)"
    } until ($response -eq "y" -or $response -eq "n")
    switch ($response) {
        "y" { 
            Remove-Item -Path $OutputPath -Include "*.mkv", "*.mp4" -Confirm 
            if ($?) { Write-Host "`nFile $OutputPath was successfully deleted" }
            else { Write-Host "$OutputPath could not be deleted. Make sure it is not in use by another program.`nExiting script..."; exit }
        }
        "n" { "Please choose a different file name, or delete the existing file. Exiting script..."; exit }
        default { Write-Host "You have somehow reached an unreachable block. Exiting script..."; exit }
    }
}

$checkOS = Get-OperatingSystem
$cropFilePath = New-CropFile $checkOS.OperatingSystem
Start-Sleep -Seconds 5
$cropDim = Measure-CropDimensions $cropFilePath
Invoke-FFMpeg $checkOS.OperatingSystem

$endTime = (Get-Date).ToLocalTime()
$totalTime = $endTime - $startTime
Write-Host "`nTotal Encoding Time: $($totalTime.Hours) Hours, $($totalTime.Minutes) Minutes" 

Read-Host -Prompt "Press enter to exit"





















#:max-cll=1347,546
#frames:v 1000
#cropdetect -f null
# ffmpeg.exe -probesize 100MB -i "M:\Blu Ray Rips\Jurassic Park II The Lost World 1997 UHD Blu-ray 2160p HDR Remux Multi DTS-X 7.1-DTOne\Jurassic Park II The Lost World 1997 UHD Blu-ray 2160p HDR Remux Multi DTS-X 7.1-DTOne.mkv" `
#         -frames:v 1000 -vf "crop=w=3840:h=2076" -color_range tv -color_primaries 9 -color_trc 16 -colorspace 9 -c:v libx265 -preset slow -crf 16.0 -pix_fmt yuv420p10le `
#         -x265-params "level-idc=5.1:min-keyint=23:keyint=250:deblock=-1,-1:sao=0:rc-lookahead=48:subme=4:chromaloc=2:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(10000000,50):max-cll=929,129:hdr-opt=1" `
#         "M:\Blu Ray Rips\Jurassic Park II The Lost World 1997 UHD Blu-ray 2160p HDR Remux Multi DTS-X 7.1-DTOne\Jurassic Park II The Lost World.mkv"
